#!/usr/bin/python3

import sys
import argparse
from glob import glob

from lxml import etree


def get_header_footer(first_file):
    s = ''
    doc = etree.iterparse(first_file)
    for act, elem in doc:
        if elem.tag[-4:] == 'html':
            children = elem.getchildren()
            for child in children:
                if child.tag[-4:] == 'body':
                    chs = child.getchildren()
                    for c in chs:
                        child.remove(c)
            s = etree.tostring(elem, pretty_print=True, method='xml',
                               encoding='UTF-8', xml_declaration=True)
            s = s.decode('utf-8')
            break

    comp = s.split('<body>')

    # XML-ho
    header = comp[0] + '<body>' + '\n'
    htmlidx = header.find('<html')
    doctype = '''<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'''
    header = header[:htmlidx] + doctype + '\n' + header[htmlidx:]

    footer = comp[1].lstrip()

    return header.encode('utf-8'), footer.encode('utf-8')


def process_files(files_to_process):
    top, bottom = get_header_footer(files_to_process[0])

    sys.stdout.buffer.write(top)

    page_no = 0

    for f in files_to_process:
        doc = etree.iterparse(f)
        for act, elem in doc:
            if elem.tag[-3:] == 'div' and elem.attrib['class'] == 'ocr_page':
                page = elem

                page.tag = 'div'

                page.attrib['id'] = 'page_%.06d' % page_no
                block_no = 0
                par_no = 0
                line_no = 0
                word_no = 0

                blocks = page.xpath("*[@class='ocr_carea']")
                for block in blocks:
                    block.attrib['id'] = 'block_%.06d_%.06d' % (page_no,
                                                                block_no)

                    paragraphs = block.xpath("*[@class='ocr_par']")
                    for par in paragraphs:
                        par.attrib['id'] = 'par_%.06d_%.06d' % (page_no,
                                                                par_no)

                        for line in par.getchildren():
                            line.attrib['id'] = 'line_%.06d_%.06d' % (page_no,
                                                                      line_no)

                            words = line.xpath("*[@class='ocrx_word']")
                            for word in words:
                                word.attrib['id'] = 'word_%.06d_%.06d' % \
                                        (page_no, word_no)

                                word_no += 1

                            line_no += 1

                        par_no += 1

                    block_no += 1

                page_no += 1

                s = etree.tostring(page, pretty_print=True, method='xml',
                                   encoding='utf-8').decode('utf-8')
                # Let's Remove the xmlns in the div.
                # Yes, this is horrible, but cleanup_namespaces doesn't help
                # since as far as tostring knows, this is the root.
                # Let's also # add two spaces for indendation for the first
                # page, and one for
                # all the other pages.
                if page_no == 1:
                    s = '  ' + \
                        s.replace(' xmlns="http://www.w3.org/1999/xhtml"', '')
                else:
                    s = ' ' + \
                        s.replace(' xmlns="http://www.w3.org/1999/xhtml"', '')

                s = s.encode('utf-8')
                sys.stdout.buffer.write(s)

                # Ditch page element, saves ram
                elem.clear()

        del doc

    sys.stdout.buffer.write(bottom)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Combine hOCR files '
                                     '- streaming version')
    parser.add_argument('-g', '--glob', help='Glob of files to parse',
                        type=str, default=None)
    args = parser.parse_args()

    files_to_process = glob(args.glob)

    if not len(files_to_process):
        import sys
        print('No files to process!', file=sys.stderr)
        sys.exit(1)

    files_to_process = sorted(files_to_process)

    process_files(files_to_process)
